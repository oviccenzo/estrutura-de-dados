<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra Pro - Rotas e Tabela</title>
    <style>
        :root {
            --primary: #4a90e2;
            --success: #2ecc71;
            --bg: #f4f4f9;
            --panel: #ffffff;
            --text: #333;
            --selected-node: #ffeaa7;
            --selected-edge: #e74c3c;
            --highlight-path: #2ecc71; /* Verde para a rota */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            user-select: none;
        }

        h1 { margin-bottom: 10px; }

        .controls-wrapper {
            width: 100%;
            max-width: 1200px;
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .panel {
            background: var(--panel);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 300px;
        }

        .btn-group { display: flex; gap: 10px; margin-top: 10px; }

        button {
            padding: 10px 15px;
            cursor: pointer;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            transition: background 0.2s;
            flex: 1;
        }

        button:hover { background-color: #357abd; }
        button.secondary { background-color: #95a5a6; }
        button.secondary:hover { background-color: #7f8c8d; }
        button.success { background-color: var(--success); }
        button.success:hover { background-color: #27ae60; }

        /* Estilo dos Selects */
        .route-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
            flex: 1;
        }

        .main-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 1200px;
        }

        #canvas-container {
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
            background: white;
            border: 2px solid #ddd;
            position: relative;
        }

        canvas { display: block; cursor: default; }

        .table-container {
            flex: 1;
            min-width: 300px;
            background: var(--panel);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
        }

        table { width: 100%; border-collapse: collapse; font-size: 14px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #f8f9fa; font-weight: bold; color: #d35400; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .first-col { font-weight: bold; text-align: left; white-space: nowrap; }

        /* Result Display */
        #pathResult {
            margin-top: 10px;
            padding: 10px;
            background: #e8f5e9;
            border-radius: 5px;
            color: #2e7d32;
            font-weight: bold;
            display: none; /* Escondido inicialmente */
        }

        /* Modal */
        #weightModal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background: white; padding: 20px; border-radius: 8px; width: 300px; text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .modal-content input { width: 80%; padding: 8px; margin: 10px 0; border: 1px solid #ccc; border-radius: 4px; }

        .instructions { font-size: 0.85em; color: #555; line-height: 1.4; }
    </style>
</head>
<body>

    <h1>Dijkstra Interativo</h1>
    
    <div class="controls-wrapper">
        <div class="panel">
            <h3>1. Edição do Grafo</h3>
            <div class="instructions">
                • <b>Duplo Clique:</b> Criar Vértice<br>
                • <b>Clique + Clique:</b> Criar Aresta<br>
                • <b>Arrastar:</b> Mover Vértice<br>
                • <b>Delete:</b> Apagar Seleção
            </div>
            <div class="btn-group">
                <button onclick="calculateTable()">Gerar Tabela (Passo a Passo)</button>
                <button class="secondary" onclick="clearCanvas()">Limpar Tudo</button>
            </div>
        </div>

        <div class="panel">
            <h3>2. Encontrar Melhor Rota</h3>
            <div class="instructions">Selecione origem e destino para ver o caminho.</div>
            
            <div class="route-controls">
                <label for="startNodeSelect"></label><select id="startNodeSelect"><option>-</option></select>
                <span>&rarr;</span>
                <label for="endNodeSelect"></label><select id="endNodeSelect"><option>-</option></select>
            </div>
            
            <div class="btn-group">
                <button class="success" onclick="findAndHighlightPath()">Mostrar Rota</button>
            </div>

            <div id="pathResult"></div>
        </div>
    </div>

    <div class="main-container">
        <div id="canvas-container">
            <canvas id="graphCanvas" width="600" height="500"></canvas>
        </div>

        <div class="table-container">
            <h3>Tabela de Iterações (Baseada no Nó Inicial 'A')</h3>
            <div id="resultTable">Aguardando cálculo...</div>
        </div>
    </div>

    <div id="weightModal">
        <div class="modal-content">
            <h3>Peso da Aresta</h3>
            <p>Custo entre <span id="modalNodes"></span>:</p>
            <label for="weightInput"></label><input type="number" id="weightInput" min="1" placeholder="Valor inteiro">
            <br>
            <div class="btn-group">
                <button onclick="confirmWeight()">Salvar</button>
                <button class="secondary" onclick="closeModal()">Cancelar</button>
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- Estado do Grafo ---
    let nodes = []; 
    let edges = []; 
    let nodeCounter = 0;

    // --- Estado de Interação ---
    let selectedNode = null;
    let selectedEdge = null;
    let isDragging = false;
    let dragTarget = null;
    let dragOffset = { x: 0, y: 0 };
    let didMoveDuringDrag = false;

    // --- Estado da Rota Destacada ---
    let highlightedPathEdges = []; 
    let highlightedPathNodes = []; 

    // Modal
    let pendingConnection = null;

    // --- DOM Elements ---
    const startSelect = document.getElementById('startNodeSelect');
    const endSelect = document.getElementById('endNodeSelect');
    const pathResultDiv = document.getElementById('pathResult');

    // ==========================================================
    //                 DESENHO (DRAW LOOP)
    // ==========================================================

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Desenhar Arestas
        edges.forEach(edge => {
            const start = nodes.find(n => n.id === edge.from);
            const end = nodes.find(n => n.id === edge.to);
            if (start && end) {
                const isHighlighted = isEdgeInPath(edge);
                const isSelected = (selectedEdge === edge);
                
                drawLine(start.x, start.y, end.x, end.y, edge.weight, isSelected, isHighlighted);
            }
        });

        // 2. Desenhar Nós
        nodes.forEach(node => {
            const isHighlighted = highlightedPathNodes.includes(node.id);
            const isSelected = (selectedNode === node);

            ctx.beginPath();
            ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
            
            if (isSelected) ctx.fillStyle = 'var(--selected-node)';
            else if (isHighlighted) ctx.fillStyle = '#b9f6ca';
            else ctx.fillStyle = 'white';
            
            ctx.fill();

            if (isSelected) ctx.strokeStyle = '#fdcb6e';
            else if (isHighlighted) ctx.strokeStyle = 'var(--highlight-path)';
            else ctx.strokeStyle = '#bdc3c7';

            ctx.lineWidth = (isSelected || isHighlighted) ? 3 : 2;
            ctx.stroke();
            
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(node.id, node.x, node.y);
        });
    }

    function drawLine(x1, y1, x2, y2, weight, isSelected, isHighlighted) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        
        if (isSelected) {
            ctx.strokeStyle = 'var(--selected-edge)';
            ctx.lineWidth = 4;
        } else if (isHighlighted) {
            ctx.strokeStyle = 'var(--highlight-path)';
            ctx.lineWidth = 4;
        } else {
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 2;
        }
        ctx.stroke();

        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;
        
        ctx.fillStyle = (isSelected || isHighlighted) ? ctx.strokeStyle : '#95a5a6';
        const textMsg = String(weight);
        const padding = 6;
        const textWidth = ctx.measureText(textMsg).width;
        
        ctx.fillRect(midX - textWidth/2 - padding, midY - 12, textWidth + padding*2, 24);

        ctx.fillStyle = 'white';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(textMsg, midX, midY);
    }

    function isEdgeInPath(edge) {
        return highlightedPathEdges.some(e => 
            (e.from === edge.from && e.to === edge.to) || 
            (e.from === edge.to && e.to === edge.from)
        );
    }

    // ==========================================================
    //                 INTERAÇÃO (MOUSE/TECLADO)
    // ==========================================================

    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }

    function findNodeUnderMouse(x, y) {
        return nodes.find(n => Math.sqrt((n.x - x) ** 2 + (n.y - y) ** 2) <= 20);
    }

    function distToSegment(px, py, x1, y1, x2, y2) {
        let l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2;
        if (l2 === 0) return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
        let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
        t = Math.max(0, Math.min(1, t));
        let projX = x1 + t * (x2 - x1);
        let projY = y1 + t * (y2 - y1);
        return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
    }

    function findEdgeUnderMouse(x, y) {
        const tolerance = 6;
        return edges.find(edge => {
            const n1 = nodes.find(n => n.id === edge.from);
            const n2 = nodes.find(n => n.id === edge.to);
            if (!n1 || !n2) return false;
            return distToSegment(x, y, n1.x, n1.y, n2.x, n2.y) < tolerance;
        });
    }

    canvas.addEventListener('mousedown', (e) => {
        const pos = getMousePos(e);
        const clickedNode = findNodeUnderMouse(pos.x, pos.y);
        didMoveDuringDrag = false;

        if (clickedNode) {
            isDragging = true;
            dragTarget = clickedNode;
            dragOffset.x = pos.x - clickedNode.x;
            dragOffset.y = pos.y - clickedNode.y;
            selectedEdge = null;
        } else {
            const clickedEdge = findEdgeUnderMouse(pos.x, pos.y);
            if (clickedEdge) {
                selectedEdge = clickedEdge;
                selectedNode = null;
            } else {
                selectedNode = null;
                selectedEdge = null;
            }
        }
        draw();
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDragging && dragTarget) {
            const pos = getMousePos(e);
            dragTarget.x = pos.x - dragOffset.x;
            dragTarget.y = pos.y - dragOffset.y;
            didMoveDuringDrag = true;
            draw();
        }
        const pos = getMousePos(e);
        if (findNodeUnderMouse(pos.x, pos.y)) canvas.style.cursor = isDragging ? 'grabbing' : 'grab';
        else if (findEdgeUnderMouse(pos.x, pos.y)) canvas.style.cursor = 'pointer';
        else canvas.style.cursor = 'default';
    });

    canvas.addEventListener('mouseup', (e) => {
        if (isDragging) {
            isDragging = false;
            if (!didMoveDuringDrag && dragTarget) handleNodeClick(dragTarget);
            dragTarget = null;
        }
        draw();
    });

    canvas.addEventListener('dblclick', (e) => {
        const pos = getMousePos(e);
        if (!findNodeUnderMouse(pos.x, pos.y)) {
            createNode(pos.x, pos.y);
            draw();
        }
    });

    // CORREÇÃO AQUI: Verifica se o modal está aberto antes de deletar
    document.addEventListener('keydown', (e) => {
        const modal = document.getElementById('weightModal');
        // Se o modal estiver visível, não processe a exclusão do nó/aresta
        if (modal.style.display === 'flex') return;

        if (e.key === 'Delete' || e.key === 'Backspace') {
            if (selectedNode) deleteNode(selectedNode);
            else if (selectedEdge) deleteEdge(selectedEdge);
            draw();
        }
    });

    // ==========================================================
    //                 LÓGICA DO GRAFO
    // ==========================================================

    function createNode(x, y) {
        const id = String.fromCharCode(65 + nodeCounter);
        nodeCounter++;
        nodes.push({ id, x, y });
        updateSelectOptions();
        clearPathHighlight();
    }

    function handleNodeClick(clickedNode) {
        if (!selectedNode) selectedNode = clickedNode;
        else if (selectedNode === clickedNode) selectedNode = null;
        else openWeightModal(selectedNode, clickedNode);
    }

    function deleteNode(nodeToDelete) {
        nodes = nodes.filter(n => n !== nodeToDelete);
        edges = edges.filter(e => e.from !== nodeToDelete.id && e.to !== nodeToDelete.id);
        selectedNode = null;
        updateSelectOptions();
        clearPathHighlight();
    }

    function deleteEdge(edgeToDelete) {
        edges = edges.filter(e => e !== edgeToDelete);
        selectedEdge = null;
        clearPathHighlight();
    }

    // ==========================================================
    //                 MODAL E UI AUXILIAR
    // ==========================================================

    const modal = document.getElementById('weightModal');
    const weightInput = document.getElementById('weightInput');

    function openWeightModal(node1, node2) {
        pendingConnection = { node1, node2 };
        document.getElementById('modalNodes').innerText = `${node1.id} - ${node2.id}`;
        weightInput.value = '';
        modal.style.display = 'flex';
        weightInput.focus();
    }

    function confirmWeight() {
        const weight = parseInt(weightInput.value);
        if (!isNaN(weight) && weight > 0 && pendingConnection) {
            const n1 = pendingConnection.node1;
            const n2 = pendingConnection.node2;
            const fromId = (n1.id < n2.id) ? n1.id : n2.id;
            const toId = (n1.id < n2.id) ? n2.id : n1.id;

            edges = edges.filter(e => !(e.from === fromId && e.to === toId));
            edges.push({ from: fromId, to: toId, weight: weight });
            
            selectedNode = null;
            closeModal();
            draw();
            clearPathHighlight();
        } else {
            alert("Peso inválido.");
        }
    }

    function closeModal() {
        modal.style.display = 'none';
        pendingConnection = null;
    }

    weightInput.addEventListener("keypress", (e) => { if(e.key === "Enter") confirmWeight(); });

    function clearCanvas() {
        if(confirm("Apagar tudo?")) {
            nodes = []; edges = []; nodeCounter = 0;
            selectedNode = null; selectedEdge = null;
            clearPathHighlight();
            updateSelectOptions();
            document.getElementById('resultTable').innerHTML = 'Aguardando cálculo...';
            draw();
        }
    }

    function updateSelectOptions() {
        const sortedNodes = [...nodes].sort((a,b) => a.id.localeCompare(b.id));
        let html = '<option value="">-</option>';
        sortedNodes.forEach(n => {
            html += `<option value="${n.id}">${n.id}</option>`;
        });
        startSelect.innerHTML = html;
        endSelect.innerHTML = html;
    }

    function clearPathHighlight() {
        highlightedPathEdges = [];
        highlightedPathNodes = [];
        pathResultDiv.style.display = 'none';
        draw();
    }

    // ==========================================================
    //                 ALGORITMO DIJKSTRA
    // ==========================================================

    function calculateTable() {
        if (nodes.length < 2) return alert("Crie nós e arestas primeiro.");
        const sortedNodes = [...nodes].sort((a, b) => a.id.localeCompare(b.id));
        const startId = sortedNodes[0].id;
        const result = runDijkstra(startId, null, true);
        renderTable(result.snapshots, sortedNodes);
    }

    function renderTable(snapshots, sortedNodes) {
        let html = '<table><thead><tr><th>Iteração</th>';
        sortedNodes.forEach(n => html += `<th>${n.id}</th>`);
        html += '</tr></thead><tbody>';

        snapshots.forEach(row => {
            html += `<tr><td class="first-col">${row.iteration.replace(/\((.)\)/, '(<span style="color:red">$1</span>)')}</td>`;
            sortedNodes.forEach(n => html += `<td>${row.cells[n.id]}</td>`);
            html += `</tr>`;
        });
        html += '</tbody></table>';
        document.getElementById('resultTable').innerHTML = html;
    }

    function findAndHighlightPath() {
        const startId = startSelect.value;
        const endId = endSelect.value;

        if (!startId || !endId) return alert("Selecione Origem e Destino.");
        if (startId === endId) return alert("Origem e Destino são iguais.");

        clearPathHighlight();

        const result = runDijkstra(startId, endId, false);
        const dist = result.distances[endId];
        const prev = result.previous;

        if (dist === Infinity) {
            pathResultDiv.innerText = `Não há caminho entre ${startId} e ${endId}.`;
            pathResultDiv.style.display = 'block';
            pathResultDiv.style.backgroundColor = '#ffebee';
            pathResultDiv.style.color = '#c62828';
            return;
        }

        let path = [];
        let curr = endId;
        while (curr) {
            path.push(curr);
            curr = prev[curr];
            if (curr === startId) {
                path.push(curr);
                break;
            }
        }
        path.reverse(); 

        highlightedPathNodes = [...path];
        
        for (let i = 0; i < path.length - 1; i++) {
            let u = path[i];
            let v = path[i+1];
            highlightedPathEdges.push({ from: u, to: v }); 
        }

        pathResultDiv.innerHTML = `Melhor Rota: <b>${path.join(' &rarr; ')}</b> <br> Custo Total: <b>${dist}</b>`;
        pathResultDiv.style.display = 'block';
        pathResultDiv.style.backgroundColor = '#e8f5e9';
        pathResultDiv.style.color = '#2e7d32';

        draw(); 
    }

    function runDijkstra(startId, targetId, recordSnapshots) {
        let distances = {};
        let previous = {};
        let unvisited = new Set();
        let snapshots = [];

        nodes.forEach(node => {
            distances[node.id] = Infinity;
            previous[node.id] = null;
            unvisited.add(node.id);
        });
        distances[startId] = 0;
        
        let iterationCount = 1;

        while (unvisited.size > 0) {
            let currentNodeId = null;
            let minDist = Infinity;
            unvisited.forEach(id => {
                if (distances[id] < minDist) {
                    minDist = distances[id];
                    currentNodeId = id;
                }
            });

            if (currentNodeId === null) break; 
            if (targetId && currentNodeId === targetId && !recordSnapshots) break;

            unvisited.delete(currentNodeId);

            const neighbors = edges.filter(e => e.from === currentNodeId || e.to === currentNodeId);
            
            neighbors.forEach(edge => {
                const neighborId = (edge.from === currentNodeId) ? edge.to : edge.from;
                if (unvisited.has(neighborId)) {
                    const newDist = distances[currentNodeId] + edge.weight;
                    if (newDist < distances[neighborId]) {
                        distances[neighborId] = newDist;
                        previous[neighborId] = currentNodeId;
                    }
                }
            });

            if (recordSnapshots) {
                let rowSnapshot = {
                    iteration: `${iterationCount}ºIt(${currentNodeId})`,
                    cells: {}
                };
                nodes.forEach(n => {
                    const d = distances[n.id];
                    const p = previous[n.id];
                    rowSnapshot.cells[n.id] = (d === Infinity) ? '∞' : `(${d},${(p && p!==n.id && distances[n.id]!==0) ? p : '-'})`;
                });
                snapshots.push(rowSnapshot);
                iterationCount++;
            }
        }
        return { distances, previous, snapshots };
    }

    draw();

</script>
</body>
</html>